#!/usr/bin/env bash
set -euo pipefail

# Release EKV to Hex with precompiled NIF binaries.
#
# Usage:
#   ./hex_release           # release current @version from mix.exs
#   ./hex_release 0.2.0     # bump to 0.2.0, commit, tag, and release
#   ./hex_release --force   # retry current version (re-tag and re-run CI)

REPO="chrismccord/ekv"
POLL_INTERVAL=15
TIMEOUT=900  # 15 minutes
FORCE=false

# Parse flags
for arg in "$@"; do
  case "$arg" in
    --force) FORCE=true ;;
    v[0-9]*) NEW_VERSION="${arg#v}" ;;  # strip leading v
    [0-9]*) NEW_VERSION="$arg" ;;
    *)
      echo "error: unknown argument '$arg'" >&2
      echo "usage: ./hex_release [VERSION] [--force]" >&2
      exit 1
      ;;
  esac
done

version_from_mix() {
  grep '@version "' mix.exs | head -1 | sed 's/.*@version "\(.*\)"/\1/'
}

if [ "${NEW_VERSION:-}" != "" ]; then
  CURRENT=$(version_from_mix)
  if [ "$CURRENT" != "$NEW_VERSION" ]; then
    echo "==> Bumping @version $CURRENT -> $NEW_VERSION in mix.exs"
    sed -i '' "s/@version \"$CURRENT\"/@version \"$NEW_VERSION\"/" mix.exs
    git add mix.exs
    git commit -m "Bump version to $NEW_VERSION"
  fi
fi

VERSION=$(version_from_mix)
TAG="v$VERSION"

echo "==> Releasing EKV $TAG"

# Preflight checks
if ! command -v gh &>/dev/null; then
  echo "error: gh CLI is required (brew install gh)" >&2
  exit 1
fi

if ! git diff --quiet || ! git diff --cached --quiet; then
  echo "error: working directory is dirty â€” commit or stash first" >&2
  exit 1
fi

if git tag -l "$TAG" | grep -q "$TAG"; then
  if [ "$FORCE" = true ]; then
    echo "==> Force: deleting existing tag $TAG"
    git tag -d "$TAG"
    git push origin ":refs/tags/$TAG" 2>/dev/null || true
    # Delete existing GitHub release so artifacts are fresh
    gh release delete "$TAG" --yes 2>/dev/null || true
  else
    echo "error: tag $TAG already exists (use --force to retag)" >&2
    exit 1
  fi
fi

BRANCH=$(git rev-parse --abbrev-ref HEAD)

# Record any existing run ID so we can skip it when polling for the new one
OLD_RUN_ID=$(gh run list --workflow=precompile.yml --branch="$TAG" --limit=1 --json databaseId,headBranch \
  --jq ".[] | select(.headBranch == \"$TAG\") | .databaseId" 2>/dev/null || true)

echo "==> Tagging $TAG on $BRANCH"
git tag "$TAG"
git push origin "$BRANCH" "$TAG"

# Wait for all precompile CI jobs to finish
echo "==> Waiting for precompile CI to finish (timeout ${TIMEOUT}s)..."

elapsed=0
while true; do
  # Find the workflow run triggered by our tag (skip old run if retrying)
  RUN_ID=$(gh run list --workflow=precompile.yml --branch="$TAG" --limit=1 --json databaseId,headBranch \
    --jq ".[] | select(.headBranch == \"$TAG\") | .databaseId" 2>/dev/null || true)

  # Skip stale run from previous attempt
  if [ -n "$OLD_RUN_ID" ] && [ "$RUN_ID" = "$OLD_RUN_ID" ]; then
    RUN_ID=""
  fi

  if [ -n "$RUN_ID" ]; then
    STATUS=$(gh run view "$RUN_ID" --json status,conclusion --jq '.status')
    if [ "$STATUS" = "completed" ]; then
      CONCLUSION=$(gh run view "$RUN_ID" --json conclusion --jq '.conclusion')
      if [ "$CONCLUSION" = "success" ]; then
        echo "==> Precompile CI passed"
        break
      else
        echo "error: precompile CI failed (conclusion: $CONCLUSION)" >&2
        echo "  https://github.com/$REPO/actions/runs/$RUN_ID" >&2
        exit 1
      fi
    fi
    printf "\r    waiting... %ds (status: %s)  " "$elapsed" "$STATUS"
  else
    printf "\r    waiting for run to appear... %ds  " "$elapsed"
  fi

  sleep "$POLL_INTERVAL"
  elapsed=$((elapsed + POLL_INTERVAL))
  if [ "$elapsed" -ge "$TIMEOUT" ]; then
    echo ""
    echo "error: timed out waiting for precompile CI after ${TIMEOUT}s" >&2
    exit 1
  fi
done

# Generate checksums from the GitHub release artifacts
echo "==> Generating checksums"
MIX_ENV=prod mix elixir_make.checksum --all --ignore-unavailable

if [ ! -f checksum.exs ]; then
  echo "error: checksum.exs was not created" >&2
  exit 1
fi

# Publish to Hex
echo "==> Publishing to Hex"
MIX_ENV=docs mix hex.publish

echo ""
echo "==> Done! EKV $TAG published to Hex"
echo "    https://hex.pm/packages/ekv/$VERSION"
